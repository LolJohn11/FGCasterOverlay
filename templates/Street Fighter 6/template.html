<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scoreboard Overlay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Backup font just in case -->
  <!-- <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@700&display=swap" rel="stylesheet" /> -->
  <link rel="stylesheet" href="./static/fa/css/all.min.css" />
  <link rel="stylesheet" href="{{ asset_url(template_name, 'template.css') }}">
  <script src="https://cdn.jsdelivr.net/npm/fitty@2.3.7/dist/fitty.min.js"></script>
</head>
<body>

<!-- Defines which game's character list to use. -->
<!-- Write in "value" field the end of the URL of the game's page on https://www.fightersgeneration.com/ -->
<!-- For example, for Tekken 8, the page is https://www.fightersgeneration.com/games/tekken8.html, so you must write "tekken8" in the value field.-->
<input type="hidden" id="overlayGame" value="sf6" />

<div class="debug-bg-container">
   <!-- Add images like this: -->
   <!-- <img src="{{ asset_url(template_name, 'img/Image.png') }}" alt=""> -->
   <!-- Debug background image of a game. Set opacity to 1 or 0 to show or hide -->
   <img src="{{ asset_url(template_name, 'img/game.jpg') }}" style="opacity: 0;" class="debug-bg" alt="Debug Game Background">
   <img id="p1BGpartial" src="{{ asset_url(template_name, 'img/img_p1_noimg.png') }}" data-anim="right" class="bg-img" alt="Player 1 Plaque">
   <img id="p2BGpartial" src="{{ asset_url(template_name, 'img/img_p2_noimg.png') }}" data-anim="left" class="bg-img" alt="Player 2 Plaque">
   <img id="p1BGfull" src="{{ asset_url(template_name, 'img/img_p1.png') }}" data-anim="right" class="bg-img" alt="Player 1 Plaque">
   <img id="p2BGfull" src="{{ asset_url(template_name, 'img/img_p2.png') }}" data-anim="left" class="bg-img" alt="Player 2 Plaque">
   <img id="topRowBG" src="{{ asset_url(template_name, 'img/img_toprow.png') }}" data-anim="down" class="bg-img" alt="Top Text Row">
   <img id="team1BG" src="{{ asset_url(template_name, 'img/img_team_1_noimg.png') }}" data-anim="right" class="bg-img" alt="Team 1 Plaque">
   <img id="team2BG" src="{{ asset_url(template_name, 'img/img_team_2_noimg.png') }}" data-anim="left" class="bg-img" alt="Team 1 Plaque">
   <img id="team1BGFull" src="{{ asset_url(template_name, 'img/img_team_1.png') }}" data-anim="right" class="bg-img" alt="Team 1 Plaque">
   <img id="team2BGFull" src="{{ asset_url(template_name, 'img/img_team_2.png') }}" data-anim="left" class="bg-img" alt="Team 1 Plaque">
   <img id="castersBG" src="{{ asset_url(template_name, 'img/img_casters.png') }}" data-anim="up" class="bg-img" alt="Casters Row">
   <!-- MAIN TOP SECTION -->
   <div class="scoreboardContainer">
      <!-- LEFT: Player 1 -->
      <div class="imgBlock" data-anim="right">
         <img id="player1Img" class="playerImg" src="" alt="" />
      </div>
      <div class="nameBlock" id="nameBlockP1" data-anim="right">
         <div class="name">
            <span id="player1Clan"></span> <span id="separator1">|</span>
            <span id="player1Name"></span>
            <span id="player1WL"></span>
         </div>
      </div>
      <div class="scoreBlock" data-anim="right">
         <div class="score" id="player1Score"></div>
      </div>
      <!-- CENTER: Stage, Match Type, Top Text, etc. -->
      <div class="centerPanel" data-anim="down">
         <div class="infoRow">
            <div class="infoBar" id="stageText"></div>
            <div class="infoBar" id="topText"></div>
            <div class="infoBar" id="matchTypeText"></div>
         </div>
      </div>
      <!-- RIGHT: Player 2 -->
      <div class="scoreBlock" data-anim="left">
         <div class="score" id="player2Score"></div>
      </div>
      <div class="nameBlock" id="nameBlockP2" data-anim="left">
         <div class="name">
            <span id="player2Clan"></span> <span id="separator2">|</span>
            <span id="player2Name"></span>
            <span id="player2WL"></span>
         </div>
      </div>
      <div class="imgBlock" data-anim="left">
         <img id="player2Img" class="playerImg" src="" alt="" />
      </div>
   </div>
   <!-- TEAMS -->
   <div class="teamsContainer">
      <div class="team team-left" data-anim="right">
         <img id="team1Img" class="teamImg" src="" alt="" />
         <div class="teamText">
            <span id="team1Name"></span>
            <span id="team1Score"></span>
         </div>
      </div>
      <div id="teamsDivider"></div>
      <div class="team team-right" data-anim="left">
         <div class="teamText">
            <span id="team2Score"></span>
            <span id="team2Name"></span>
         </div>
         <img id="team2Img" class="teamImg" src="" alt="" />
      </div>
   </div>
   <!-- CASTERS -->
   <div id="casterContainer" class="scoreboardContainer" data-anim="up">
      <div class="commentators" id="commentatorsBlock">
         <span id="casterCycleWrapper" class="fade">
            <span id="caster1Display" class="casterText"></span>
            <span class="casterIcon" id="micIcon" style="display: none;"><i class="fa-solid fa-headset"></i></span>
            <span class="casterIcon" id="twitchIcon" style="display: none;"><i class="fa-brands fa-twitch" style="color: #772CE8"></i></span>
            <span class="casterIcon" id="twitterIcon" style="display: none;"><i class="fa-brands fa-x-twitter" style="color: #1DA1F2"></i></span>
            <span id="caster2Display" class="casterText"></span>
         </span>
      </div>
   </div>
</div>


<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
let socket;

function connectSocket() {
   socket = io({
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 2000,
      timeout: 5000
   });

   socket.on('connect', () => {
      console.log('%c[Overlay] Connected to server', 'color: green');
   });

   socket.on('disconnect', (reason) => {
      console.warn('[Overlay] Disconnected:', reason);
   });

   socket.on('reconnect_attempt', () => {
      console.log('[Overlay] Attempting to reconnect...');
   });

   socket.on('reconnect', (attemptNumber) => {
      console.log(`[Overlay] Reconnected after ${attemptNumber} attempt(s)`);
   });

   // When the controller changes the template, reload once to get the new HTML/CSS
   socket.on('template_changed', (msg) => {
      // Only reload if the message says a different template than what this page was rendered with
      if (msg && msg.template && msg.template !== "{{ template_name }}") {
         location.reload();
      }
   });

   socket.on('update_scoreboard', data => {
      
	  // Update player 1 name
	  if (data.player1?.name !== undefined) {
		const p1NameEl = document.getElementById('player1Name');
		if (p1NameEl) {
			p1NameEl.textContent = data.player1.name;
		}
	  }

	  // Update player 2 name
	  if (data.player2?.name !== undefined) {
		const p2NameEl = document.getElementById('player2Name');
		if (p2NameEl) {
			p2NameEl.textContent = data.player2.name;
		}
	  }
	  
	  try {
         const d = data || {};
         const p1 = d.player1 || {
            name: '',
			id: '',
            clan: '',
            wl: '',
            score: 0,
			character: '',
            img: ''
         };
         const p2 = d.player2 || {
            name: '',
			id: '',
            clan: '',
            wl: '',
            score: 0,
			character: '',
            img: ''
         };

		 //////// Players

         const clan1 = (p1.clan || '')
            .trim();
         const name1 = (p1.name || '')
            .trim();
         const clan2 = (p2.clan || '')
            .trim();
         const name2 = (p2.name || '')
            .trim();
		
		 const p1Char = (p1.character || '').trim();
		 const p2Char = (p2.character || '').trim();
		
		 const p1ID = (p1.id || '').trim();
		 const p2ID = (p2.id || '').trim();

         const p1Img = document.getElementById('player1Img');
         const p2Img = document.getElementById('player2Img');

         p1Img.src = p1.img || '';
         p1Img.style.display = p1.img ? 'inline-block' : 'none';
         p1Img.classList.remove('flag-style', 'custom-image-style');
         p1Img.classList.add(p1.img && p1.img.includes('/flags/') && p1.img.endsWith('.svg') ? 'flag-style' : 'custom-image-style');

         if (!p1.img) { // BG partial/full
            document.getElementById('p1BGpartial')
               .style.display = 'block';
            document.getElementById('p1BGfull')
               .style.display = 'none';
         } else {
            document.getElementById('p1BGfull')
               .style.display = 'block';
            document.getElementById('p1BGpartial')
               .style.display = 'none';
         }

         p2Img.src = p2.img || '';
         p2Img.style.display = p2.img ? 'inline-block' : 'none';
         p2Img.classList.remove('flag-style', 'custom-image-style');
         p2Img.classList.add(p2.img && p2.img.includes('/flags/') && p2.img.endsWith('.svg') ? 'flag-style' : 'custom-image-style');

         if (!p2.img) {
            document.getElementById('p2BGpartial')
               .style.display = 'block';
            document.getElementById('p2BGfull')
               .style.display = 'none';
         } else {
            document.getElementById('p2BGfull')
               .style.display = 'block';
            document.getElementById('p2BGpartial')
               .style.display = 'none';
         }

         document.getElementById('player1Name')
            .textContent = name1;
         document.getElementById('player1Clan')
            .textContent = clan1;
         document.getElementById('player1WL')
            .textContent = p1.wl || '';
         document.getElementById('player1Score')
            .textContent = Number.isFinite(p1.score) ? p1.score : 0;

         document.getElementById('player2Name')
            .textContent = name2;
         document.getElementById('player2Clan')
            .textContent = clan2;
         document.getElementById('player2WL')
            .textContent = p2.wl || '';
         document.getElementById('player2Score')
            .textContent = Number.isFinite(p2.score) ? p2.score : 0;
		// Insert a "|" separator between player name and clan tag if both are present
         document.getElementById('separator1')
            .style.display = (clan1 && name1) ? 'inline' : 'none';
         document.getElementById('separator2')
            .style.display = (clan2 && name2) ? 'inline' : 'none';

         const stage = (data.stage || '')
            .trim();
         const matchType = (data.match_type || '')
            .trim();
         const topText = (data.toptext || '')
            .trim();
		
		 //////// Top info bar
		 
         document.getElementById('stageText')
            .textContent = stage;
         document.getElementById('matchTypeText')
            .textContent = matchType;
         document.getElementById('topText')
            .textContent = topText;

         // Toggle topRowBG visibility based on whether any top info exists
         const topRowBG = document.getElementById('topRowBG');
         if (stage || matchType || topText) {
            topRowBG.style.display = 'block'; // show if any value exists
         } else {
            topRowBG.style.display = 'none'; // hide if all are empty
         }

		 //////// Teams

         const t1 = data.team1 || {
            name: '',
            score: 0,
            img: ''
         };
         const t2 = data.team2 || {
            name: '',
            score: 0,
            img: ''
         };

         const t1Name = (t1.name || '')
            .trim();
         const t2Name = (t2.name || '')
            .trim();
         const t1Score = Number.isFinite(t1.score) ? t1.score : 0;
         const t2Score = Number.isFinite(t2.score) ? t2.score : 0;

         const team1BG = document.getElementById('team1BG');
         const team1BGFull = document.getElementById('team1BGFull');
         const team2BG = document.getElementById('team2BG');
         const team2BGFull = document.getElementById('team2BGFull');

         const hasAny1 = !!(t1Name || t1Score > 0 || (t1.img && t1.img.trim()));
         const hasAny2 = !!(t2Name || t2Score > 0 || (t2.img && t2.img.trim()));

         const hasImg1 = !!(t1.img && t1.img.trim());
		 const hasImg2 = !!(t2.img && t2.img.trim());

		 function show(el, on) { if (el) el.style.display = on ? 'block' : 'none'; }
		
		 if (!hasAny1) {
		   show(team1BG, false);
		   show(team1BGFull, false);
		 } else {
		   show(team1BGFull, hasImg1);     // full when any image (flag or custom)
		   show(team1BG, !hasImg1);        // partial when no image but some team data
		 }

		 if (!hasAny2) {
		   show(team2BG, false);
		   show(team2BGFull, false);
		 } else {
		   show(team2BGFull, hasImg2);
		   show(team2BG, !hasImg2);
		 }

         document.getElementById('team1Name')
            .textContent = t1Name;
         document.getElementById('team2Name')
            .textContent = t2Name;
         document.getElementById('team1Score')
            .textContent = t1Score;
         document.getElementById('team2Score')
            .textContent = t2Score;

         // Hide teams display if score = 0 AND neither BG is shown
         const team1ScoreEl = document.getElementById('team1Score');
         const team2ScoreEl = document.getElementById('team2Score');

         function isShown(el) {
            return !!(el && el.style.display !== 'none');
         }

         const hideScore1 = (t1Score === 0) && !isShown(team1BG) && !isShown(team1BGFull);
         const hideScore2 = (t2Score === 0) && !isShown(team2BG) && !isShown(team2BGFull);

         team1ScoreEl.textContent = hideScore1 ? '' : String(t1Score);
         team2ScoreEl.textContent = hideScore2 ? '' : String(t2Score);

         const t1ImgEl = document.getElementById('team1Img');
         const t2ImgEl = document.getElementById('team2Img');

         t1ImgEl.src = t1.img || '';
         t2ImgEl.src = t2.img || '';

         t1ImgEl.style.display = t1.img ? 'inline-block' : 'none';
         t2ImgEl.style.display = t2.img ? 'inline-block' : 'none';

         // reset + set style classes depending on whether it’s a flag SVG or a custom image
		 [t1ImgEl, t2ImgEl].forEach(el => el.classList.remove('flag-style', 'custom-image-style'));
         if (t1.img) {
            t1ImgEl.classList.add(t1.img.includes('/flags/') && t1.img.endsWith('.svg') ? 'flag-style' : 'team-custom-image-style');
         }
         if (t2.img) {
            t2ImgEl.classList.add(t2.img.includes('/flags/') && t2.img.endsWith('.svg') ? 'flag-style' : 'team-custom-image-style');
         }

		 //////// Casters

         const c1Name = (data.caster1?.name ?? "")
            .trim();
         const c2Name = (data.caster2?.name ?? "")
            .trim();
         const c1Twitch = (data.caster1?.twitch ?? "")
            .trim();
         const c2Twitch = (data.caster2?.twitch ?? "")
            .trim();
         const c1Twitter = (data.caster1?.twitter ?? "")
            .trim();
         const c2Twitter = (data.caster2?.twitter ?? "")
            .trim();

         // Show casters row/bg only if any of the caster's names exist
         const hasAnyCaster = !!(c1Name || c2Name);
         const castersBG = document.getElementById('castersBG');
         const casterContainer = document.getElementById('casterContainer');
         if (castersBG) castersBG.style.display = hasAnyCaster ? 'block' : 'none';
         if (casterContainer) casterContainer.style.display = hasAnyCaster ? 'block' : 'none';

         const newDataHash = JSON.stringify([c1Name, c2Name, c1Twitch, c2Twitch, c1Twitter, c2Twitter]);

         const changed = newDataHash !== lastCasterData;
         if (changed) lastCasterData = newDataHash;

         // Hide everything if no caster names
         if (!c1Name && !c2Name) {
            clearInterval(casterCycleTimeout);
            document.getElementById("casterCycleWrapper")
               .classList.add("fade-hidden");
         }

         // Store structured data
         caster1Info = {
            name: c1Name,
            twitch: c1Twitch,
            twitter: c1Twitter.trim()
               .startsWith("@") ? c1Twitter.trim() : "@" + c1Twitter.trim()
            // if you don't want an @ tag in the beginning - replace previous line with this one:
            //twitter: c1Twitter
         };

         caster2Info = {
            name: c2Name,
            twitch: c2Twitch,
            twitter: c2Twitter.trim()
               .startsWith("@") ? c2Twitter.trim() : "@" + c2Twitter.trim()
            // if you don't want an @ tag in the beginning - replace previous line with this one:
            //twitter: c2Twitter
         };
		 
		 //////// Caster animation handling
         // Build / (re)start rotation only if data actually changed
         if (changed) {
            displayPhases = [];
            if (c1Name || c2Name) displayPhases.push("name");
            if (c1Twitch || c2Twitch) displayPhases.push("twitch");
            if (c1Twitter || c2Twitter) displayPhases.push("twitter");

            clearTimeout(casterCycleTimeout);

            // Ensure wrapper starts hidden until we decide what to do
            const wrapper = document.getElementById('casterCycleWrapper');
            if (wrapper) wrapper.classList.add('fade-hidden');

            const container = document.getElementById('casterContainer');

            // Make sure wrapper starts hidden
            if (wrapper) wrapper.classList.add('fade-hidden');

            // Start only after the entrance is done (but only once)
            const kick = () => startCasterCycle();

            if (!casterEntranceSynced) {
               casterEntranceSynced = true;
               waitForEntranceEnd(container, 3000)
                  .then(kick);
            } else {
               kick();
            }
         }

      } catch (err) {
         console.error('[overlay] update_scoreboard crashed:', err);
      } finally {
         // Always signal “first data applied” so the unified orchestrator can start
         markFirstDataAppliedOnce();
      }
	  
	  fitAllPlayerNames();
	  
   });
}
connectSocket();

function fitTextToContainer(element, maxFontSize = 26, minFontSize = 14) {
    if (!element) return;
    
    const container = element.closest('.nameBlock');
    if (!container) return;
    
    // Hide the element while resizing
    element.style.visibility = 'hidden';
    
    // Available width: container width - padding - safety buffer
    const availableWidth = container.offsetWidth - 10;
    
    let fontSize = maxFontSize;
    element.style.fontSize = fontSize + 'px';
    element.style.whiteSpace = 'nowrap';
    
    // Reduce font size until it fits
    while (element.scrollWidth > availableWidth && fontSize > minFontSize) {
        fontSize -= 0.5;
        element.style.fontSize = fontSize + 'px';
    }
    
    // Show the element after resizing is complete
    element.style.visibility = 'visible';
    
    console.log(`Fitted text: "${element.textContent}" to ${fontSize}px (width: ${element.scrollWidth}px / ${availableWidth}px)`);
}

function fitAllPlayerNames() {
    document.querySelectorAll('.name').forEach(el => {
        fitTextToContainer(el, 26, 14);
    });
}

window.addEventListener('load', fitAllPlayerNames);

//////////// Reload overlay when server announces new template
socket.on('template_changed', ({
   template
}) => {
   location.reload();
});

//////////// Debug functions
function setDebugBg() {
   const randomColor = "#" + ((1 << 24) * Math.random() | 0)
      .toString(16);

   document.documentElement.style.setProperty('--debug-bg-color', randomColor);
}
setDebugBg();

//////////// Caster additinal functions
let caster1Info = {};
let caster2Info = {};
let displayPhases = []; // The actual rotation sequence (e.g., ["name", "twitch"])
let currentPhaseIndex = 0;
let casterCycleTimeout;
let casterEntranceSynced = false; // waitForEntranceEnd only once
let isTransitioning = false; // true during fade-out + fade-in
let restartPending = false; // request restart after transition
const FADE_MS = parseFloat(getComputedStyle(document.documentElement)
   .getPropertyValue('--fade-duration')) || 500; //get value from the CSS to match the .fade animation duration
let isCycling = false; // Prevents desync from restarts
let lastCasterData = ""; // To track data changes

//////////// Caster animation cycle

// How long each caster's value will stay on screen (in ms)
const displayDurations = {
   name: 20000,
   twitch: 6000,
   twitter: 6000
};

function updateCasterDisplayCycle() {
   const wrapper = document.getElementById("casterCycleWrapper");
   isTransitioning = true;

   // Safety: if phases got cleared, stop cleanly
   if (!displayPhases.length) {
      wrapper.classList.add("fade-hidden");
      isTransitioning = false;
      isCycling = false;
      return;
   }

   // Fade out current phase
   wrapper.classList.add("fade-hidden");

   setTimeout(() => {
      const phase = displayPhases[currentPhaseIndex];

      // Update content + icons
      renderCasterPhase(phase);

      // When fade-in finishes, we are no longer in a transition
      const onEnd = (e) => {
         if (e.target !== wrapper || e.propertyName !== 'opacity') return;
         wrapper.removeEventListener('transitionend', onEnd, true);
         isTransitioning = false;

         // If a restart was requested during the transition, honor it now
         if (restartPending) {
            restartPending = false;
            startCasterCycle();
            return;
         }

         // Schedule next phase
		 if (displayPhases.length) {
			currentPhaseIndex = (currentPhaseIndex + 1) % displayPhases.length;
		  } else {
			isCycling = false;
			return;
		 }

         // Schedule next phase
         currentPhaseIndex = (currentPhaseIndex + 1) % displayPhases.length;
         casterCycleTimeout = setTimeout(() => {
            updateCasterDisplayCycle();
         }, displayDurations[phase]);
      };
      wrapper.addEventListener('transitionend', onEnd, true);

   }, FADE_MS); // matches CSS fade-out duration
}

function renderCasterPhase(phase) {
   const wrapper = document.getElementById("casterCycleWrapper");
   const c1Display = document.getElementById("caster1Display");
   const c2Display = document.getElementById("caster2Display");
   const micIcon = document.getElementById("micIcon");
   const twitchIcon = document.getElementById("twitchIcon");
   const twitterIcon = document.getElementById("twitterIcon");

   c1Display.textContent = caster1Info[phase] || "";
   c2Display.textContent = caster2Info[phase] || "";

   micIcon.style.display = phase === "name" ? "inline-block" : "none";
   twitchIcon.style.display = phase === "twitch" ? "inline-block" : "none";
   twitterIcon.style.display = phase === "twitter" ? "inline-block" : "none";

   wrapper.classList.remove("fade-hidden"); // show it
}

function startCasterCycle() {
   const wrapper = document.getElementById("casterCycleWrapper");

   // No phases at all → hide and bail
   if (!displayPhases.length) {
	  clearTimeout(casterCycleTimeout);
	  isCycling = false;
	  restartPending = false;
	  wrapper.classList.add("fade-hidden");
      return;
   }

   // Single (or zero) phase → just render once, do NOT schedule rotation
   if (displayPhases.length <= 1) {
      clearTimeout(casterCycleTimeout);
      isCycling = false;
      restartPending = false;
      if (displayPhases.length === 1) {
         renderCasterPhase(displayPhases[0]);
      } else {
         // no phases, stay hidden
         wrapper.classList.add("fade-hidden");
      }
      return;
   }

   // Don't restart in the middle of a fade transition
   if (isTransitioning) {
      restartPending = true;
      return;
   }

   clearTimeout(casterCycleTimeout);
   isCycling = true;
   currentPhaseIndex = 0;
   updateCasterDisplayCycle();
}

//////////// Global animations

let resolveEntranceDone;
const entranceDone = new Promise(res => (resolveEntranceDone = res));

// 1) Prepare CSS variables from data attributes so its possible to control timing per element
function primeAnimVariables() {
   document.querySelectorAll('[data-anim]')
      .forEach(el => {
         const d = el.getAttribute('data-delay');
         const u = el.getAttribute('data-dur');
         if (d) el.style.setProperty('--delay', `${parseInt(d,10)}ms`);
         if (u) el.style.setProperty('--dur', `${parseInt(u,10)}ms`);
      });
}

// 2) Gate #1: resolve when the FIRST scoreboard payload has been applied (one-shot)
let _firstApplied = false;
let _resolveFirst;
const firstDataReady = new Promise(res => (_resolveFirst = res));

function markFirstDataAppliedOnce() {
   if (_firstApplied) return;
   _firstApplied = true;
   try {
      _resolveFirst();
   } catch (e) {}
}

// 3) Gate #2: wait for decode on BGs that will actually be visible after that first update
function visibleBgImgs() {
   return Array.from(document.querySelectorAll('.bg-img'))
      .filter(el => getComputedStyle(el)
         .display !== 'none' && el.offsetParent !== null);
}

function waitForDecodeOn(imgs, capMs = 1500) {
   if (!imgs.length) return Promise.resolve();
   const jobs = imgs.map(img => {
      if (typeof img.decode !== 'function') return Promise.resolve();
      return img.decode()
         .catch(() => {}); // treat SVG decode errors as ready
   });
   return Promise.race([
Promise.all(jobs)
      .catch(() => {}),
new Promise(r => setTimeout(r, capMs))
]);
}

// 4) One-shot start
let animStarted = false;
async function startAnimationsWhenReady() {
   if (animStarted) return;
   animStarted = true;

   // FIRST, ensure elements know their per-element timings
   primeAnimVariables();

   // Wait for the first data to be applied
   const DATA_CAP = 2000;
   await Promise.race([firstDataReady, new Promise(r => setTimeout(r, DATA_CAP))]);

   // After first update decided which BGs are visible, wait for those to decode (bounded)
   const decodeTargets = visibleBgImgs();
   const DECODE_CAP = 2000;
   await waitForDecodeOn(decodeTargets, DECODE_CAP);

   // Open the entrance window: trigger keyframes once
   document.body.classList.add('anim-start');

   // Compute how long to keep the window open
   const visibleAnimEls = Array.from(document.querySelectorAll('[data-anim]'))
      .filter(el => getComputedStyle(el)
         .display !== 'none' && el.offsetParent !== null);

   const longestMs = visibleAnimEls.reduce((max, el) => {
      const delay = parseInt(el.getAttribute('data-delay') || '0', 10) || 0;
      const dur = parseInt(el.getAttribute('data-dur') || '500', 10) || 500;
      return Math.max(max, delay + dur);
   }, 0);

   // Close the window right after the longest entrance finishes, then lock final states and prevent any future replays
   const ENTRANCE_MS = Math.max(700, longestMs + 1000); // safety margin
   setTimeout(() => {
      document.body.classList.add('post-entrance'); // persist final state, no replays
      document.body.classList.remove('anim-start'); // stop matching the animation selectors
      try {
         resolveEntranceDone?.();
      } catch {}
   }, ENTRANCE_MS);

   // (Optional) watchdog in case something crazy happened earlier
   //setTimeout(() => { document.body.classList.add('anim-start'); }, 4000);
}

// 5) Kick off animations at file parse time
startAnimationsWhenReady();

////// For caster animations or others that are done after the entrance animations
// Resolves when the initial entrance window is over.
// - immediately resolves if post-entrance is already set
// - resolves on entranceDone (from orchestrator)
// - also resolves if the element’s own animation ends OR is cancelled
function waitForEntranceEnd(el, capMs = 3000) {
   if (document.body.classList.contains('post-entrance')) {
      return Promise.resolve();
   }
   return new Promise(resolve => {
      let settled = false;
      const done = () => {
         if (settled) return;
         settled = true;
         cleanup();
         resolve();
      };

      // Global entrance completion
      entranceDone.then(done)
         .catch(done);

      // Element-level fallbacks (end or cancel)
      const onEnd = e => {
         if (!el || e.target === el) done();
      };
      const onCancel = e => {
         if (!el || e.target === el) done();
      };
      if (el) {
         el.addEventListener('animationend', onEnd, true);
         el.addEventListener('animationcancel', onCancel, true);
      }

      // Body class flip observed
      const mo = new MutationObserver(() => {
         if (document.body.classList.contains('post-entrance')) done();
      });
      mo.observe(document.body, {
         attributes: true,
         attributeFilter: ['class']
      });

      // Hard cap
      const to = setTimeout(done, capMs);

      function cleanup() {
         clearTimeout(to);
         mo.disconnect();
         if (el) {
            el.removeEventListener('animationend', onEnd, true);
            el.removeEventListener('animationcancel', onCancel, true);
         }
      }
   });
}

</script>
</body>
</html>